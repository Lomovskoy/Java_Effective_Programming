#### Собрав все сказанное вместе, мы получаем рецепт для создания высококачественного метода equals.
***
1. Используйте оператор == для проверки того, что аргумент является
   ссылкой на данный объект. Если это так, возвращайте true. Это
   просто оптимизация производительности, которая может иметь смысл
   при потенциально дорогостоящем сравнении.
***
2. Используйте оператор instanceof для проверки того, что аргумент
   имеет корректный тип. Если это не так, возвращайте false. Обычно
   корректный тип — это тип класса, которому принадлежит данный
   метод. В некоторых случаях это может быть некоторый интерфейс,
   реализованный этим классом. Если класс реализует интерфейс, который
   уточняет контракт метода equals, то в качестве типа указывайте этот
   интерфейс: это позволит выполнять сравнение классов, реализующих
   этот интерфейс. Подобным свойством обладают интерфейсы коллекций,
   таких как Set, List, Мар и Map. Entry.
   78 ГЛABA 3 МЕТОДЫ, ОБЩИЕДЛЯ ВСЕХ ОБЪЕКТОВ
***
3. Приводите аргумент к корректному типу. Поскольку эта операция
   следует за проверкой instanceof, она гарантированно успешна.
***
4. Для каждого “важного” поля класса убедитесь, что значение этого
   поля в аргументе соответствует полю данного объекта. Если все тесты
   успешны, возвращайте true; в противном случае возвращайте false.  
   Если в п. 2 тип определен как интерфейс, вы должны получить доступ
   к полям аргумента через методы интерфейса; если тип представляет
   собой класс, вы можете обращаться к его полям непосредственно, в
   зависимости от их доступности.  
   Для примитивных полей, тип которых — не float и не double,
   для сравнения используйте оператор ==; для полей, которые представляют собой ссылки на объекты, рекурсивно вызывайте метод
   equals; для полей float воспользуйтесь статическим методом
   Float. compare (float, float), а для полей double — Double .
   compare (double, double).  
   Отдельное рассмотрение полей float
   и double необходимо из-за существования Float .NaN, -0 . Of и аналогичных значений типа double (см. подробную документацию по
   Float. equals в [25, 15.21.1]). При сравнении полей float и double
   с помощью статических методов Float. equals и Double. equals для
   каждого сравнения выполняется автоматическая упаковка, что отрицательно сказывается на производительности. В случае полей-массивов
   применяйте эти рекомендации к каждому элементу. Если каждый элемент в поле-массиве имеет значение, воспользуйтесь одним из методов
   Arrays.equals.  
   Некоторые ссылки на объекты могут оправданно содержать значение
   null. Чтобы избежать возможности генерации исключения NullPointerException, проверяйте такие поля на равенство с использованием
   статического метода Objects.equals (Object, Object).  
   Для некоторых классов, таких как рассматривавшийся выше CaselnsensitiveString, сравнение полей оказывается более сложным, чем
   простая проверка равенства. В таком случае вы можете захотеть сохранить поле в некотором каноническом виде так, чтобы метод equals мог
   выполнять дешевое точное сравнение канонических значений вместо
   применения более дорогостоящего нестандартного сравнения. Эта методика лучше всего подходит для неизменяемых классов (раздел 4.3); если
   объект может изменяться, требуется поддерживать актуальность канонической формы.  
   На производительность метода equals может оказывать влияние порядок сравнения полей. Чтобы добиться наилучшей производительности,
   3.1. ПЕРЕКРЫВАЯ EQUALS, СОБЛЮДАЙТЕ ОБЩИЙ КОНТРАКТ 79
   в первую очередь, следует сравнивать те поля, которые будут различны
   с большей вероятностью, либо те, сравнение которых дешевле, либо, в
   идеале, и те, и другие. Не следует сравнивать поля, которые не являются
   частью логического состояния объекта, например такие, как поля блокировок, используемые для синхронизации операций.  
   Не нужно сравнивать
   производные поля (derived fields), значение которых вычисляется на основе “значащих полей” объекта; однако такое сравнение может повысить
   производительность метода equals. Если значение производного поля
   равнозначно суммарному описанию объекта в целом, то сравнение подобных полей позволит сэкономить на сравнении фактических данных,
   если будет выявлено расхождение. Например, предположим, что есть
   класс Polygon, площадь которого кешируется. Если два многоугольника имеют разные площади, нет смысла сравнивать их ребра и вершины.