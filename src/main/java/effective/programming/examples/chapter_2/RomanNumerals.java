package effective.programming.examples.chapter_2;

import java.util.regex.Pattern;

/**
 * Избегайте создания излишних объектов
 */
public class RomanNumerals {

    // Проблема этой реализации в том, что она опирается на метод String.
    // matches. Хотя String.matches — простейший способ проверки, соответ
    // ствует ли строка регулярному выражению, он не подходит для многократ
    // ного использования в ситуациях, критичных в смысле производительнос
    // ти.
    // Беда в том, что он внутренне создает экземпляр Pattern для регулярного
    // выражения и использует его только один раз, после чего он становится добычей
    // сборщика мусора. Создание экземпляра Pattern достаточно дорогостоящее,
    // поскольку требует компиляции регулярного выражения в конечный автомат.
    // Для повышения производительности, как часть инициализации класса,
    // можно явно компилировать регулярное выражение в экземпляр Pattern (ко
    // торый является неизменяемым) и повторно использовать тот же экземпляр для
    // каждого вызова метода isRomanNumeral:
    static boolean isRomanNumeralBed(String s) {
        return s.matches("^(?=.)M*(C[MD]|D?C{0,3})\"\n"
                + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
    }

    // Повторное использование дорогостоящего объекта
    // для повышения производительности
    private static final Pattern ROMAN =
            Pattern.compile("^(?=.)M*(C[MD]|D?C{0,3})"
                    + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");

    static boolean isRomanNumeral(String s) {
        return ROMAN.matcher(s).matches();
    }
}
